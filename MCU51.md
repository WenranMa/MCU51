# 51单片机

## 硬件相关
TTL电平（晶体管-晶体管逻辑电平），大于2.4V为高，小于0.4V为低。51单片机（89C52RC）高电平为5V。

串口RS232电平，高为-12V，低为+12V。CH340是串口芯片，做电平转换，RS232转为TTL？

```
同或：必须相同，否则没有（为0）。
异或：必须不同，否则没有。
```
```
电容：
1F = 1000000uF（微法）
1uF = 1000nF
1nF = 1000pF
电容104表示10x10^4pF，也就是100nF。

板上电容：
470uF电容做储能，储备电荷量，防止供电电压被拉低。
100nF电容做滤波，防止浪涌。
```

## 51 C语言
```c
//头文件<reg51.h>包含了寄存器的一些定义。
sfr     //声明一个特殊功能寄存器
sfr16   //声明一个16位特殊功能寄存器
sbit    //特殊功能位声明，也就是声明一个寄存器中的某一位
sbit Led = P0^0; //表示声明P0寄存器的最低位
```

```c
//<intrins.h>中保护左移右移函数：
unsigned char _crol_(unsigned char c, unsigned char b);
//将c循环左移b位
unsigned char _cror_(unsigned char c, unsigned char b);
//将c循环右移b位
```

## 74HC573锁存器
20个管脚，包括Vcc，GND，D1~8为数据输入，Q1~8为输出。OE是输出使能，低电平有效，LE是锁存控制。

|Input  |       |       |Output |
|-------|-------|-------|-------|
|OE     |LE     |D      |Q      |
|L      |H      |H      |H      |
|L      |H      |L      |L      |
|L      |L      |H/L    |Q0（上一次状态）|
|H      |H/L    |H/L    |Z（高阻态，不可控）|

- OE为低，LE为低时，输出跟随输入。
- OE为低，LE为高时，不管输入是什么，输出都保持上一次的状态。
- OE高时，输出不可控。

所以板上的OE都接地。通过控制LE来控制输出。

## 4位数码管
一共12个引脚，其中ABCDEFGH是8段LED，WE1-4负责位选择。

板上两个4位数码管，一共8位显示，两个74HC573，一个负责数码管位选择，一个负责实际数字（或者简单字母）选择。

## 周期
- 时钟周期：外接晶振的倒数。单片机最小时间单位，单片机完成一个基本动作。
- 状态周期：时钟周期的2倍。
- 机器周期：12个时钟周期，6个状态周期。一个机器周期完成一个基本操作，如存储器读、写等。
- 指令周期：完成一个指令的周期，1~4个机器周期组成。

```c
for(i=1000; i>0; i--){
	for(j=110; j>0; j--){			
	}
}
//为什么循环110000次大概时1秒?
```

消影？？？

## PSW寄存器
Program Status Word.

## 中断
中断源：52型号有6个中断源（优先级从高到低，中断号从0到5，c语言用）。
- INT0 外部中断0，P3.2管脚引入，低电平或下降沿触发，优先级最高。
- T0 定时器/计数器0中断，T0计数器计满归零触发。
- INT1 外部中断1，P3.3管脚引入，低电平或下降沿触发。
- T1 定时器/计数器1中断，T1计数器计满归零触发。
- TI/RI 串口中断。
- T2 定时器/计数器2中断，T2计数器计满归零触发，优先级最低，52独有。

中断可以嵌套。

### 中断允许寄存器IE
- EA：中断总允许位。EA=1，开放中断；EA=0，禁止所有的中断请求。
- EX0：外部中断0允许位。EX0=1，允许外部中断0中断；EX0=0，禁止外部中断0中断。
- ET0：T0溢出中断允许位。ET0=1，允许T0中断；ET0=0，禁止T0中断。
- EX1：外部中断1允许位。EX1=1，允许外部中断1中断；EX1=0，禁止外部中断1中断。
- ET1：T1溢出中断允许位。ET1=1，允许T1中断；ET1=0，禁止T1中断。
- ES：串行中断允许位。ES=1，允许串行口中断；ES=0，禁止串行口中断。
- ET2：T2溢出中断允许位。ET2=1，允许T2中断；ET2=0，禁止T2中断。

### 中断优先寄存器IP

### 定时器/计数器
定时器/计数器是一个16位加1计数器。它随着计数器的输入脉冲进行自加1，也就是每来一个脉冲，计数器就自动加1。这里的脉冲有两个来源：
- 时钟振荡器的12分频
- 外部引脚T0，T1

简单说定时器的中断有两种方式，一种是计数值达到最大（定时或计数都可以），会产生溢出中断。另一种是外部脉冲触发中断（只有计数时），此时的中断标志位IT需要软件清除。

当加到计数器为全1时，再输入一个脉冲就使计数器回零，且计数器的溢出使相应的中断标志位置1（TCON的TF0，TF1），向CPU发出中断请求（定时/计数器中断允许时）。如果定时/计数器工作于定时模式，则表示定时时间已到；如果工作于计数模式，则表示计数值已满。

可见，由溢出时计数器的值减去计数初值才是加1计数器的计数值。

定时/计数器的实质是加1计数器（16位），由高8位和低8位两个寄存器THx和TLx组成。

当选择计数功能是每一次脉冲，TH或TL寄存器的值会自动加一，当超出选定模式容纳的最大计数值是，TF会硬件置一，产生中断。

选择定时功能时，每一个机器周期都会自动加一，一直加到选定模式的容许的最大值，此时会出发中断。

TMOD是定时/计数器的工作方式寄存器，确定工作方式和功能；TCON是控制寄存器，控制T0、T1的启动和停止及设置溢出标志。

#### TMOD工作方式寄存器
工作方式寄存器TMOD用于设置定时/计数器的工作方式，低四位用于T0，高四位用于T1。
|D7  |D6  |D5  |D4  |D3  |D2  |D1  |D0  |
|----|----|----|----|----|----|----|----|
|GATE|C/T |M1  |M0  |GATE|C/T |M1  |M0  |

GATE是门控位： 
- GATE=0时，定时器的启动由TCON中的TR0或TR1控制。TR0/TR1为1，就可以启动定时/计数器工作；
- GATA=1时，要用软件使TR0或TR1为1，同时外部中断引脚INT0/1也为高电平时，才能启动定时/计数器工作。

C/T :定时/计数模式选择位。
- C/T=0为定时模式。
- C/T=1为计数模式。

M1/M0：工作方式设置位。定时/计数器有四种工作方式。

|M1  |M0  |工作方式                                     |
|----|----|--------------------------------------------|
|0   |0   |方式0，13位计数                              |
|0   |1   |方式1，16位计数                              |
|1   |0   |方式2，自动重装初值的8位计数                  |
|1   |1   |方式3，只适用于T0，分成两个8位计数器，T1停止计数|

`注意TMOD不可以位寻址。`

#### TCON控制寄存器
TCON的低4位用于控制外部中断，TCON的高4位用于控制定时/计数器的启动和中断申请。
|D7  |D6  |D5  |D4  |D3  |D2  |D1  |D0  |
|----|----|----|----|----|----|----|----|
|TF1 |TR1 |TF0 |TR0	|IE1 |IT1 |IE0 |IT0 |

TF1（TCON.7）：T1溢出标志位。T1计数溢出时由硬件自动置TF1为1。CPU响应中断后TF1由硬件自动清0。T1工作时，CPU可随时查询TF1的状态。TF1也可以用软件置1或清0，同硬件置1或清0的效果一样。

TR1（TCON.6）：T1运行控制位。TR1置1时，T1开始工作；TR1置0时，T1停止工作。TR1由软件置1或清0。所以，用软件可控制定时/计数器的启动与停止。(至于TMOD中GATE的设置，如果GATE=1，还需要外部中断源INT1为高才能控制。)

TF0（TCON.5）：T0溢出标志位，其功能与TF1类同。

TR0（TCON.4）：T0运行控制位，其功能与TR1类同。

IE1：外部中断源1（INT1，P3.3）标志。IE1＝1，外部中断1正在向CPU请求中断，当CPU响应该中断时由硬件清零IE1。

IT1：外部中断源1触发方式控制位。
- IT1＝0，外部中断1程控为电平触发方式，当INT1（P3.3）输入低电平时，置位IE1。
- IT1=1时，为边沿触发方式。

IE0：外部中断源0（INT0，P3.2）标志，同IE1。

IT0：外部中断源0触发方式控制位。同IT0。

#### 初始值计算
机器周期也就是CPU完成一个基本操作所需要的时间。

使用12MHZ的外部晶振，时钟周期(振荡周期) = 1/12MHz，机器周期(1个机器周期等于12个振荡周期) = (1/12MHz) * 12 = 1us。（如果采用方式1即为16位定时/计数器，那么一次记满就最多为65536 * 1us = 65536us）

如果用定时器0，并采用方式一(16位定时/计数器)，而我们定时1ms的初值是多少呢，1ms/1us=1000。也就是要计数1000个数，初值 = 65535 - 1000 + 1（因为实际上计数器计数到65536才溢出）= 64536 = 0xFC18（可这样赋值：TH0 = 0xFC，也就是((65536-1000)/256)，TL0=0x18，即((65536-1000)%256))，256就是8位的最大值。

比如定时50ms，如果晶振是12M，那么一个机器周期是12 * 1 / 12MHz = 1us。如果我们定时50ms，那么计数器加了50ms/1us = 50000次。初始值 = 65536-50000 = 15536。

11.0592MHz的晶振，一个机器周期 = 12 * (1/11.0592Mhz) ~= 1.09us，如果时50ms，50ms / 1.09us = 45872，初值 = 65536 - 45872 = 10664。


## 按键
### 独立按键
### 矩阵键盘

## 蜂鸣器
板载时有源蜂鸣器，只要加上电源，就会发出固定频率的声音，不可以调节频率。

## 8x8点阵
一共16个引脚，组成64阵列。

### 74HC595
是一个8位串行输入，并行输出的芯片。两片595级联可以实现16位并行输出，刚好可以驱动8x8点阵。

|管脚 |说明     |
|-----|--------|
|Q0~Q7| 8位并行数据输出 |
|GND  |	地             |
|Q7’  |	串行数据输出，级联输出端，接下一个595的DS端 |
|MR   |	低电平有效，清空移位寄存器中的数据，一般不用，接高电平即可 |
|SH_CP或SCK | 移位寄存器时钟引脚，上升沿时，移位寄存器中的数据整体后移，并接受新的数据(从DS输入)。|
|ST_CP或RCK | 存储寄存器时钟输入引脚。上升沿时，数据从移位寄存器并行输出到Q0~Q7 | 
|OE   |	低电平有效，输出使能控制脚，所以接GND |
|DS	  |	串行数据输入引脚 |
|VCC  |	电源  |


## AD

- 分辨率：8位，满刻度的1/2^8，比如8位5V满刻度，分辨率就是5V/256 ~= 20mV。
- 量化误差：用数字量表示模拟量的过程，叫量化。要准确表示模拟量，需要无限位。
- 偏移误差：
- 满刻度误差：
- 线性度：
- 绝对精度：
- 转换速度：

ADC类型:
- 双积分
- 逐次逼近：二分查找原理。内置逐次逼近寄存器，首先产生8位最大值的一半 1000 0000，用这个值的产生的模拟量Vn与Vin比较，如果Vin < Vn，最高位1保留，否则置0。再看第二位，x100 0000，再比较，直到最后一位确定。
- 并行比较

### XPT2046
- 4线电阻式触摸控制器，内置12位，125KHz转换速率逐次逼近AD转换器。
- 工作电压1.5V-5.25V。
- 三线制SPI（Serial Peripheral Interface，串行外设接口）通信接口。 
- TSSOP 16脚封装引脚：
	1. Vcc
	2. XP，模拟信号差分输入，也可以单端输入使用，单端输入时，是与GND的差分值。
	3. YP
	4. XN
	5. YN
	6. GND
	7. VBAT，电池监视输入端，也可以做模拟输入。
	8. AUX，ADC辅助输入通道，也可以做模拟输入。
	9. VREF，参考电压输入/输出。
	10. IOVDD，数字电源输入端。
	11. PENIRQ，笔接触中断引脚。
	12. DOUT，串行数据输出端。数据在DCLK的下降沿移出，当CS为高电平时为高阻状态。
	13. Busy，忙信号，当CS为高电平时为高阻状态。
	14. DIN，串行数据输入端。当CS为低电平时，数据在DCLK上升沿锁存进来。
	15. CS，片选信号。控制转换时序和使能串行输入输出寄存器，高电平时ADC掉电。
	16. DCLK，外部时钟信号输入。

所以最多有四通道（XP，YP，Vbat，AUX）模拟输入。

差分信号可以抑制共模干扰。比如v+输入2v，v-输入1v，最终信号是2-1 = 1v。共模干扰就是同时干扰v+，v-，干扰后v+变为2.15v，v-变为1.15v，差值仍是1v。

DIN输入的是命令信号，前8个时钟用来通过DIN引脚输入控制字节。

控制字节：
- 起始位，第一位，即S位。控制字的首位必须是1，即S＝1。在XPT2046的DIN引脚检测到起始位前，所有的输入将被忽略。
- 地址，接下来的3位（A2、A1和A0）选择多路选择器的现行通道，触摸屏驱动和参考源输入。参考Data sheet.
- MODE，模式选择位，用于设置ADC的分辨率。MODE＝0，下一次的转换将是12位模式；MODE＝1，下一次的转换将是8位模式。
- SER/DFR，SER/DFR位控制参考源模式，选择单端模式（SER/DFR＝1），或者差分模式（SER/DFR＝0）。
- PD0和PD1，低功率模式选择位，若为11，器件总处于供电状态，若为00，器件在模数转换之间处于低功率模式。


### 光敏电阻
光照后，阻值会下降。

### 热敏电阻
大多数位负温度系数，阻值随温度上升而减小。

### 电位器
可调电阻

## DA
### PWM脉冲宽度调制

面积等效原理：电压不同时间不同的两组输入，如果它们的电压和时间的乘积相等，则等效？？？？

惯性环节？？？

Pulse Width Modulation，是脉冲宽度调制，是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。

是利用微处理器的数字信号对模拟电路进行控制的一种非常有效的技术。
 
对于LED的光度调节。
简单的说，比如你有5V电源，要控制一台灯的亮度，有一个传统办法，就是串联一个可调电阻，改变电阻，灯的亮度就会改变。此种调节方式，需要认为的去旋转滑动变阻器也就是可调电阻器。

还有一个办法，就是PWM调节。不用串联电阻，而是串联一个开关。假设在1秒内，有0.5秒的时间开关是打开的，0.5秒关闭，那么灯就亮0.5秒，灭0.5秒。这样持续下去，灯就会闪烁。如果把频率调高一点，比如是1毫秒，0.5毫秒开，0.5毫秒灭，那么灯的闪烁频率就很高。我们知道，闪烁频率超过一定值，人眼就会感觉不到。所以，这时你看不到灯的闪烁，只看到灯的亮度只有原来的一半。

同理，如果1毫秒内，0.1毫秒开，0.9毫秒灭，那么，灯的亮度就只有原来的10分之一。


如何实现PWM调光
　　具体实现PWM调光的方法就是在LED的负载中串入一个MOS开关管，这串LED的阳极用一个恒流源供电。
　　然后用一个PWM信号加到MOS管的栅极，以快速地开关这串LED。从而实现调光。也有不少恒流芯片本身就带一个PWM的接口。可以直接接受PWM信号，再输出控制MOS开关管。那么这种PWM调光方去有那些优缺点呢？
　　脉宽调制调光的优点
　　1、不会产生任何色谱偏移。因为LED始终工作在满幅度电流和0之司。
　　2、可以有极高的调光精确度。因为脉中波形完全可以控制到很高的精度，所以很容易实现万分之一的精度。
　　3、可以和数字控制技术相结合来进行控制。因为任何数字都可以很容易变换成为一个PWM信号。
　　4、即使在很大范围内调光，也不会发生闪烁现象。因为不会改变恒流源的工作条件（升压比或降压比），更不可能发生过热等问题。
　　脉宽调光要注意的问题
　　1、脉冲频率的选择因为LED是处于快速开关状态，假如工作频率很低，人眼就会感到闪烁。为了充分利用人眼的视觉残留现象，它的工作频率应当高于100Hz，最好为200HZ。
　　2、消除调光弓起的啸声; 虽然200HZ以上人眼无法察觉，可是一直到20kHz却都是人耳听觉的范围。这时候就有可能会听到丝丝的声音。解决这个问题有两种方去，一是把开关频率提高到20kHz以上，跳出人耳听觉的范围。但是频率过高也会弓起一些问题，因为各种寄生参数的影响，会使脉冲波形（前后沿）产生畸变。
　　这就降低了调光的精确度。另一种方去是找出发声的器件而加以处理。实际上，主要的发声器件是输出端的陶瓷电容，因为陶瓷电容通常都是由高介电常数的陶瓷所做成，这类陶瓷都具有压电特性。在200HZ的脉冲作用下就会产生机械振动而发声。解决的方提采用钽电容来代替。对，高耐压的钽电容很得到，而且价钱很贵，会增加一些成本。


### H桥
通过电子开关控制电机



## 1602液晶

1602液晶为5V电压驱动，带背光，可显示两行，每行16个字符，不能显示汉字，内置含128个字符的 ASCII 字符集字库，只有并行接口，无串行接口。

### 管脚

![1602](/file/img/1602pin.png)

### 基本操作

![op](/file/img/1602_op.png)

### RAM地址映射图

控制器内部带有80B的RAM缓冲区，上下两行各40B，如下所示：

![address](/file/img/1602_addr.png)

当向上图中的 00~0F、40~4F 地址中的任一处写入显示数据时，液晶都可立即显示出来，当写入到10~27 (10-1F,20-27,共24个)或50~67(50-5F,60-57,共24个) 地址处时，必须通过移屏指令将它们移入可显示区域方可正常显示。

### 状态字说明

STA0 - STA7. 其中STA0 - STA6表示当前地址指针的值，STA7为读写使能，1表示禁止，为0表示允许。

原则上每次对控制器进行读/写操作之前，都必须进行读/写检测，确保STA7为0。实际上，由于单片机的操作速度慢于液晶控制器的反应速度，因此可以不进行读/写检测，或只进行简短延时即可。

### 数据指针设置

控制器内部设有一个数据地址指针，用户可以通过其访问内部的全部80B的RAM，如下表所示：

|指令码                             |功能            |
|----------------------------------|----------------|
|80H + 地址码 (00H - 27H, 40H - 67H)| 8位并行数据输出 |

### 其他设置

|指令码 |功能                                     |
|------|-----------------------------------------|
|01H   |显示清屏，1：数据指针清零，2：所有显示清零。 |
|02H   |显示回车，数据指针清零。                   	|

### 初始化设置

1. 显示模式设置

|指令码           |功能                             |
|----------------|---------------------------------|
|0 0 1 1 1 0 0 0 |设置16x2显示，5x7点阵，8位数据接口。|
	

2. 显示开/关及光标设置

|指令码           |功能                             |
|----------------|---------------------------------|
|0 0 0 0 1 D C B |D=1 开显示；D=0 关显示。          |
|                |C=1 显示光标；C=0 不显示光标。     |
|                |B=1 光标闪烁；B=0 光标不闪烁。     |
|0 0 0 0 0 1 N S |N=1 读/写一个字符后地址加1，光标加1 |
|                |N=0 读/写一个字符后地址减1，光标减1 |
|                |S=1 当写一个字符，整屏左移(N=1)或右 |
|                | 移(N=0), 光标不移动而屏幕移动效果  |
|                |S=0 当写一个字符，整屏不动         |
|0 0 0 1 0 0 0 0 |光标左移。                        |
|0 0 0 1 0 1 0 0 |光标右移。                        |
|0 0 0 1 1 0 0 0 |整屏左移，同时光标跟随移动。        |
|0 0 0 1 1 1 0 0 |整屏右移，同时光标跟随移动。        |

### 写操作时序
1. 分析RS确定是写数据还是写命令，写命令包括使液晶的光标显示与否、光标闪烁与否、是否需要移屏、液晶在何处显示等等。写数据是要显示什么内容。
2. 读/写控制端设置为写模式，即低电平；
3. 将数据或命令送达数据线上；
4. 给E一个高脉冲将数据送入液晶显示器，完成写操作。

![sequential](/file/img/1602_write_sequential.png)


## IIC 
I²C协议广泛应用于嵌入式系统中，尤其是在微控制器与各种外围设备之间的通信，如传感器、EEPROM、RTC（实时时钟）等。

### 1. 概念
- I2C（Inter-Integrated Circuit），通常简称为IIC，是一种用在集成电路（IC）之间的串行通信总线。
- I2C为同步串行通信，使用两根线路进行通信，分别是数据线（SDA）和时钟线（SCL）。
- SDA线用于数据传输，SCL线用于数据传输的同步。
- SCL的每个时钟周期，SDA传输一位数据。
- I2C规定，数据的接收方会在每个时钟周期的高电平期间读取数据，具体来讲就是在SCL处于高电平时，读取SDA上的数据。
- SDA必须在SCL低电平期准备好要发送的下一位数据，然后在SCL高电平期间保持稳定。

#### 主从架构
- I2C采用主从架构，一个主设备可连接多个从设备。主设备负责发起通信和控制总线，而从设备负责响应主设备的请求。
- I2C总线中的每个设备都有一个唯一的地址（用7位二进制数字表示，或10位），用于在总线上标识自己。
- SCL信号线上的时钟信号始终由主设备产生，而SDA信号线上的数据信号既可由主设备产生，也可由从设备产生。
- 当主设备向从设备发送数据时，SDA信号由主设备产生，从设备接收信号；当主设备从从设备读取数据时，SDA信号由从设备产生，主设备接收信号。
- 多主设备：I²C允许多个主设备（master）和多个从设备（slave）在同一总线上通信。
- 支持多主机：在多主机系统中，通过一种称为“仲裁”的机制来解决两个或多个主设备同时尝试控制总线的情况。
- 数据传输速率：I²C支持多种数据传输速率，标准模式下为100kbps，快速模式为400kbps，还有更快速的版本如快速模式加（Fast-mode Plus，1Mbps）和高速模式（High-speed Mode，3.4Mbps）。

#### 优缺点
P:

- 线路简单：只需要两根线，减少了硬件成本和PCB布局的复杂性。
- 易于扩展：可以轻松添加或移除设备，只需修改地址即可。
- 低功耗：适合低功耗应用，如便携式设备。

C:

- 速度较慢：与其他串行通信协议相比，I²C的数据传输速度较慢。
- 总线冲突：如果多个主设备尝试同时通信，可能会导致总线冲突。
- 距离限制：虽然支持长总线，但随着距离的增加，信号质量会下降。

### 2. 通信协议
- 空闲状态：I2C协议规定，当SDA和SCL均为高电平时，总线为空闲状态。
- 主设备和从设备间的每次通信，都需要以一个起始信号开始，以一个结束信号终止。
- 起始信号：当SCL处于高电平时，SDA由高变低。
- 结束信号：当SCL处于高电平时，SDA由低变高。
- 起始信号和结束信号，都只能由主设备产生。
- 确认信号：I2C协议规定，发送方每发送一个字节（8位）的数据，接收方都要向发送方回复一个1位的确认信号，0表示接收方已成功接收到该字节，发送方可继续发送下一字节，这个信号在I2C协议中称为ACK（Acknowledge）；如果该信号为1，则表示接收方未能成功接收到该字节，或者不希望接收更多数据，该信号在I2C协议中称为NACK（Not Acknowledge）。
- 从机地址：一个I2C总线上可能有多个从设备，所以开始通信前，主设备需要先与目标设备取得联系，然后再进行数据传输。
- 读写标识：主机还需要向目标设备明确本次通信的操作是写数据还是读数据。（读写两种工作模式）
- 当主设备发送起始信号之后，会向所有设备发送一个字节的数据，这一个字节中，前7位为目标设备地址，第8位为读/写标识（1表示读，0表示写）。

#### 通信流程：
- 发送起始信号；
- 发送目标从设备地址和读写标识
- 接收从设备回复的确认信号
- 与从设备数据进行传输
- 发送结束信号

### 基础驱动编写
#### 发送起始信号
- 确保处于空闲状态；
- 拉低SDA，发送起始信号；
- 拉低SCL,以便准备接下来要发送数据位；

```c
// 发送起始信号
void Dri_IIC_Start() {
    SCL = 1;
    SDA = 1;
    SDA = 0;
    SCL = 0;
}
```

#### 发送一个字节
- SCL低电平期间，准备下一位数据位；
- 拉高SCL，并在SCL高电平期间保持SDA稳定；
- 拉低SCL，以便准备下一数据位；

```c
// 发送一个字节
void Dri_IIC_SendByte(u8 byte)
{
    u8 i;
    for (i = 0; i < 8; i++) {
        SDA = (byte & (0x80 >> i)) == 0 ? 0 : 1;
        SCL = 1;
        SCL = 0;
    }
}
```

#### 接收确认信号
- 主设备释放SDA，以允许从设备驱动SDA;
- 从设备会在SCL低电平期间准备好确认信号；
- 拉高SCL，并在SCL高电平期间读取SDA的值；
- 拉低SCL，以便准备下一个数据位；

```c
// 接收确认信号
bit Dri_IIC_ReceiveAck() {
    bit ack;
    SDA = 1;
    SCL = 1;
    ack = SDA;
    SCL = 0;
    return ack;
}
```

#### 接收一个字节
- 主设备释放SDA,以允许从设备驱动SDA
- 从设备会在SCL低电平期间准备好下一个数据位；
- 拉高SCL，并在SCL高电平期间读取SDA的值；
- 拉低SCL，以便从设备准备下一个数据位；

```c
// 接收一个字节
u8 Dri_IIC_ReceiveByte()
{
    u8 byte = 0;
    u8 i;
    SDA = 1;
    for (i = 0; i < 8; i++) {
        SCL = 1;
        byte = (byte << 1) | SDA;
        SCL = 0;
    }
    return byte;
}
```

#### 发送确认信号
- SCL低电平期间，准备确认信号；
- 拉高SCL，并在SCL高电平期间保持SDA稳定；
- 拉低SCL，以便准备下一个数据位；

```c
// 发送确认信号
void Dri_IIC_SendAck(bit ack) {
    SDA = ack;
    SCL = 1;
    SCL = 0;
}
```

#### 发送结束信号
- SCL低电平期间，拉低SDA,准备发送结束信号；
- 拉高SCL,准备发送结束信号；
- SCL 高电平期间，拉高SDA，发送结束信号；

```c
// 发送结束信号
void Dri_IIC_Stop() {
    SDA = 0;
    SCL = 1;
    SDA = 1;
}
```

## IIC协议—EEPROM
EEPROM（Electrically Erasable Programmable Read-Only Memory，电可擦写可编程只读存储器）是一种非易失性存储器（断电后仍能保留数据），可以多次写入和擦除数据。

EEPROM：叫做只读存储器（ROM），但EEPROM是即可读又可写的。

ROM基本指非易失性存储器。

AT24C020CN：存储容量2K（2048位，256字节）。还有对应的2K位、4K位、16K位、32K位、64K位等，其电压可允许低至1.8V，待机电流1uA，工作电流 1mA。

### 引脚功能：

- VCC：电源输入引脚，通常连接到系统的正电源（例如5V）。
- GND：接地引脚，连接到系统的地线。
- SCL：串行时钟线（Serial Clock），用于在I²C通信中提供时钟信号。主设备通过这个引脚控制数据的时序。
- SDA：串行数据线（Serial Data），用于在主设备和AT24C02之间传输数据。
- A0、A1、A2：硬件地址引脚。这些引脚通过不同的电平组合（高电平或低电平）来确定EEPROM在I²C总线上的唯一地址。芯片地址格式为：`1010A2A1A0RW`，当A2,A1,A0引脚都接地时（GND），AT24C02的默认地址是0xA0（写操作）或0xA1（读操作）。
- WP（Write Protect，写保护）：这是一个输入引脚，用于防止EEPROM被写入。当WP引脚接高电平时，EEPROM被保护，只能读取数据，不能写入新数据。如果WP引脚接地或悬空（通常接地），则允许对EEPROM进行写入操作。

### 内存结构：
AT24C02 内部256个字节，被组织成16个数据页，每个数据页16个字节。（16x16=256 Byte, 也就是2kb）

（也有说32页，每页8个字节。）

每个字节需要一个8位地址寻址，高4位用于页寻址，低4位用于字节寻址。（如果是32页，高5位为页寻址，低3位字节寻址？）

不管怎样，片内寻址范围都是00~FF，即0~255。


### 写操作
两种写操作，页写入和字节写入

#### Byte Write
Byte Write 写入一个字节。

#### Page Write
page Write 连续写入一页数据：效率高，但容易出事故。每次指定页的头部地址，连续写一页，但如果继续发送数据，会继续写入到头部，这个现象叫“上卷”。

### 读操作
AT24C02CN提供了3种读操作，分别是Current Address Read（读当前地址）、Random Read（随机读）、Sequential Read（连续读）。

#### Current Address Read（读当前地址）
EEPROM内部有一个Address Register（地址寄存器），用于记录当前操作（读/写）的字节地址，每当完成一个字节的操作后（读/写），该地址会自动指向下一个字节。

Current Address Read读取的就是Address Register中的地址所指向的这一个字节

#### Random Read（随机读）
Random Read用于读取任意指定地址的一个字节。

#### Sequential Read（连续读）
Sequential Read用于读取连续的多个字节。其起始位置可以是Address Register记录的当前地址，也可以是用户指定的任意位置，指定起始位置的方式仍然是在Sequential Read前增加一个Dummy Write操作。

### 例子
先向EEPROM写入点阵LED中的“喜欢你”三个字的字模，再将其读取来并显示在点阵LED上。

代码实现

```c
// Int_EEPROM.c
#include "Int_EEPROM.h"
#include "Dri_IIC.h"
#define DEV_ADDR  0XA0
#define PAGE_SIZE 16
 
void Int_EEPROM_WritePage(u8 addr, u8 bytes[], u8 len)
{
    u8 i;
    Dri_IIC_Start();
    Dri_IIC_SendByte(DEV_ADDR);
    Dri_IIC_ReceiveAck();
    Dri_IIC_SendByte(addr);
    Dri_IIC_ReceiveAck();
    for (i = 0; i < len; i++) {
        Dri_IIC_SendByte(bytes[i]);
        Dri_IIC_ReceiveAck();
    }
    Dri_IIC_Stop();
    // 写入周期twr 3ms 需要延时
    Com_Util_Delay1ms(5);
}
 
void Int_EEPROM_WriteBytes(u8 addr, u8 bytes[], u8 len)
{
    u8 page_remain = PAGE_SIZE - addr % PAGE_SIZE;
    if (len > page_remain) {
        // 当前页空间不足
        // 写满当前页
        Int_EEPROM_WritePage(addr, bytes, page_remain);
        // 写剩余内容
        Int_EEPROM_WriteBytes(addr + page_remain, bytes + page_remain, len - page_remain);
    } else {
        // 当前页空间充足
        Int_EEPROM_WritePage(addr, bytes, len);
    }
}
 
void Int_EEPROM_ReadBytes(u8 addr, u8 bytes[], u8 len)
{
    u8 i;
    Dri_IIC_Start();
    Dri_IIC_SendByte(DEV_ADDR);
    Dri_IIC_ReceiveAck();
    Dri_IIC_SendByte(addr);
    Dri_IIC_ReceiveAck();
    Dri_IIC_Start();
    Dri_IIC_SendByte(DEV_ADDR + 1);
    Dri_IIC_ReceiveAck();
    for (i = 0; i < len; i++) {
        bytes[i] = Dri_IIC_ReceiveByte();
        Dri_IIC_SendAck(i == len - 1 ? 1 : 0); 
    }
    Dri_IIC_Stop();
}
 
// Int_EEPROM.h
#ifndef __INT_EEPROM_H__
#define __INT_EEPROM_H__
#include "Com_Util.h"
/**
 * @brief 发送多个字节
 * 
 * @param addr 字节地址
 * @param bytes 待发送的数据
 * @param len 数组长度
 */
void Int_EEPROM_WriteBytes(u8 addr, u8 bytes[], u8 len);
/**
 * @brief 接收多个字节
 * 
 * @param addr 字节地址
 * @param bytes 用于接收结果的数组
 * @param len 要读取的长度
 */
void Int_EEPROM_ReadBytes(u8 addr, u8 bytes[], u8 len);
 
#endif /* __INT_EEPROM_H__ */
 
// main.c
#include "Int_LEDMatrix.h"
#include "Dri_Timer0.h"
#include "Int_EEPROM.h"
 
u8 picture[26] = {0xF8, 0x0A, 0xEC, 0xAF, 0xEC, 0x8A, 0xF8, 0x00,
                  0x10, 0xF9, 0x97, 0xF1, 0x88, 0xAA, 0xFF, 0xAA,
                  0x88, 0x00, 0x14, 0x0A, 0xF5, 0x92, 0x92, 0xF5,
                  0x0A, 0x14};
u8 buffer[26];
void main()
{
    u8 i;
    Dri_Timer0_Init();
    Int_LEDMatrix_Init();
    Int_EEPROM_WriteBytes(0, picture, 26);
    Int_EEPROM_ReadBytes(0, buffer, 26);
    while (1) {
        for (i = 0; i < 26; i++) {
            Int_LEDMatrix_Shift(buffer[i]);
            Com_Util_Delay1ms(200);
        }
    }
}
```
---

